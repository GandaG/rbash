/* automatically generated by rust-bindgen */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 1;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Collection {
    _unused: [u8; 0],
}
pub type cb_collection_t = Collection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModFile {
    _unused: [u8; 0],
}
pub type cb_mod_t = ModFile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Record {
    _unused: [u8; 0],
}
pub type cb_record_t = Record;
pub type cb_formid_t = u32;
#[doc = "< TES IV: Oblivion game type."]
pub const cb_game_type_t_CB_OBLIVION: cb_game_type_t = 0;
#[doc = "< Fallout 3 game type."]
pub const cb_game_type_t_CB_FALLOUT3: cb_game_type_t = 1;
#[doc = "< Fallout: New Vegas game type."]
pub const cb_game_type_t_CB_FALLOUT_NEW_VEGAS: cb_game_type_t = 2;
#[doc = "< TES V: Skyrim game type."]
pub const cb_game_type_t_CB_SKYRIM: cb_game_type_t = 3;
pub const cb_game_type_t_CB_UNKNOWN_GAME_TYPE: cb_game_type_t = 4;
#[doc = "@brief The game types CBash can create collections for."]
#[doc = "@details The game type determines the file format CBash should assume when reading and writing plugin data."]
pub type cb_game_type_t = i32;
#[doc = "< Causes only the TES4 header record to be loaded."]
pub const cb_mod_flags_t_CB_MIN_LOAD: cb_mod_flags_t = 1;
#[doc = "< Causes all records to be loaded (unless overridden by another flag)."]
pub const cb_mod_flags_t_CB_FULL_LOAD: cb_mod_flags_t = 2;
#[doc = "@brief Causes any new record to be ignored when the mod is loaded."]
#[doc = "@details This may leave broken records behind (such as a quest override"]
#[doc = "pointing to a new script that was ignored). So it shouldn't be"]
#[doc = "used if planning on copying records unless you check that"]
#[doc = "there are no new records being referenced."]
pub const cb_mod_flags_t_CB_SKIP_NEW_RECORDS: cb_mod_flags_t = 4;
#[doc = "@brief Makes the mod count towards the 255 limit and enables record creation and copying as new."]
#[doc = "@details If it is false, it forces Saveable to be false."]
#[doc = "Any mod with new records should have this set unless you're ignoring the new records."]
#[doc = "It causes the mod to be reported by cb_GetLoadOrderNumMods(), cb_GetLoadOrderModIDs()."]
pub const cb_mod_flags_t_CB_IN_LOAD_ORDER: cb_mod_flags_t = 8;
#[doc = "< Allows the mod to be saved."]
pub const cb_mod_flags_t_CB_SAVEABLE: cb_mod_flags_t = 16;
#[doc = "@brief Causes the mod's masters to be added to the load order."]
#[doc = "@details This is essential for most mod editing functions."]
pub const cb_mod_flags_t_CB_ADD_MASTERS: cb_mod_flags_t = 32;
#[doc = "@brief Causes the mod's masters to be loaded into memory after being added."]
#[doc = "@details This has no effect if ::CB_ADD_MASTERS is false. This is"]
#[doc = "required if you want to lookup overridden records."]
pub const cb_mod_flags_t_CB_LOAD_MASTERS: cb_mod_flags_t = 64;
#[doc = "@brief Causes any conflicting records to be ignored by most functions."]
#[doc = "@details cb_IsRecordWinning(), cb_GetNumRecordConflicts(), cb_GetRecordConflicts() will report the extended conflicts only if asked."]
pub const cb_mod_flags_t_CB_EXTENDED_CONFLICTS: cb_mod_flags_t = 128;
#[doc = "@brief Causes the loader to track which record types in a mod are new and not overrides."]
#[doc = "@details Increases load time per mod. It enables cb_GetModNumTypes() and cb_GetModTypes() for the mod."]
pub const cb_mod_flags_t_CB_TRACK_NEW_TYPES: cb_mod_flags_t = 256;
#[doc = "@brief Causes LAND records to have extra indexing."]
#[doc = "@details Increases load time per mod. It allows the safe editing of"]
#[doc = "land records' heights. Modifying one LAND may require changes"]
#[doc = "in an adjacent LAND to prevent seams."]
pub const cb_mod_flags_t_CB_INDEX_LANDS: cb_mod_flags_t = 512;
#[doc = "@brief Mmoves any REFR,ACHR,ACRE records in a world cell to the actual"]
#[doc = "cell they belong to."]
#[doc = "@details Increases load time per mod. Use if you're planning on"]
#[doc = "iterating through every placeable in a specific cell, so that"]
#[doc = "you don't have to check the world cell as well."]
pub const cb_mod_flags_t_CB_FIXUP_PLACEABLES: cb_mod_flags_t = 1024;
#[doc = "< Creates a new mod instead of loading an existing one."]
pub const cb_mod_flags_t_CB_CREATE_NEW: cb_mod_flags_t = 2048;
#[doc = "@brief Causes any records that override masters not in the load order to be dropped."]
#[doc = "@details If it is true, it forces IsAddMasters to be false.  Allows"]
#[doc = "mods not in load order to copy records."]
pub const cb_mod_flags_t_CB_IGNORE_INACTIVE_MASTERS: cb_mod_flags_t = 4096;
#[doc = "< Causes all records in groups to be skipped once one of each type is read."]
pub const cb_mod_flags_t_CB_SKIP_ALL_RECORDS: cb_mod_flags_t = 8192;
#[doc = "@brief Flags that specify how a plugin is to be loaded."]
#[doc = "@details ::CB_MIN_LOAD and ::CB_FULL_LOAD are exclusive. If both are set, ::CB_FULL_LOAD takes"]
#[doc = "priority. If neither is set, the mod isn't loaded."]
#[doc = ""]
#[doc = "Only the following combinations are tested via Bash:"]
#[doc = "- Normal:  (::CB_MIN_LOAD or ::CB_FULL_LOAD) + ::CB_IN_LOAD_ORDER + ::CB_SAVEABLE + ::CB_ADD_MASTERS + ::CB_LOAD_MASTERS"]
#[doc = "- Dummy:    ::CB_ADD_MASTERS"]
#[doc = "- Merged:  (::CB_MIN_LOAD or ::CB_FULL_LOAD) + ::CB_SKIP_NEW_RECORDS + ::CB_IGNORE_INACTIVE_MASTERS"]
#[doc = "- Scanned: (::CB_MIN_LOAD or ::CB_FULL_LOAD) + ::CB_SKIP_NEW_RECORDS + ::CB_EXTENDED_CONFLICTS"]
pub type cb_mod_flags_t = i32;
#[doc = "@brief Cleans the mod's masters."]
#[doc = "@details Removed any unreferenced masters. Requires the mod to have"]
#[doc = "been loaded with the ::CB_IN_LOAD_ORDER flag."]
pub const cb_save_flags_t_CB_CLEAN_MASTERS: cb_save_flags_t = 1;
#[doc = "< Delete the parent collection after the mod is saved."]
pub const cb_save_flags_t_CB_CLOSE_COLLECTION: cb_save_flags_t = 2;
#[doc = "@brief Flags that specify how a plugin is to be saved."]
pub type cb_save_flags_t = i32;
#[doc = "< Create the record as an override of the source record."]
pub const cb_create_flags_t_CB_SET_AS_OVERRIDE: cb_create_flags_t = 1;
#[doc = "< Populate the record using data from the winning parent."]
pub const cb_create_flags_t_CB_COPY_WINNING_PARENT: cb_create_flags_t = 2;
#[doc = "@brief Flags that specify how a record is to be created."]
pub type cb_create_flags_t = i32;
#[doc = "< Data of an unknown type."]
pub const cb_field_type_t_CB_UNKNOWN_FIELD: cb_field_type_t = 0;
#[doc = "< The field is missing. Used for some fields that are not quite universal, eg. Editor IDs."]
pub const cb_field_type_t_CB_MISSING_FIELD: cb_field_type_t = 1;
#[doc = "< Junk data of unknown type."]
pub const cb_field_type_t_CB_JUNK_FIELD: cb_field_type_t = 2;
#[doc = "< A boolean value."]
pub const cb_field_type_t_CB_BOOL_FIELD: cb_field_type_t = 3;
#[doc = "< An 8-bit signed integer."]
pub const cb_field_type_t_CB_SINT8_FIELD: cb_field_type_t = 4;
#[doc = "< An 8-bit unsigned integer."]
pub const cb_field_type_t_CB_UINT8_FIELD: cb_field_type_t = 5;
#[doc = "< A 16-bit signed integer."]
pub const cb_field_type_t_CB_SINT16_FIELD: cb_field_type_t = 6;
#[doc = "< A 16-bit unsigned integer."]
pub const cb_field_type_t_CB_UINT16_FIELD: cb_field_type_t = 7;
#[doc = "< A 32-bit signed integer."]
pub const cb_field_type_t_CB_SINT32_FIELD: cb_field_type_t = 8;
#[doc = "< A 32-bit unsigned integer."]
pub const cb_field_type_t_CB_UINT32_FIELD: cb_field_type_t = 9;
#[doc = "< A 32-bit floating point value."]
pub const cb_field_type_t_CB_FLOAT32_FIELD: cb_field_type_t = 10;
#[doc = "< A 32-bit floating point value that should be interpreted as an angle measured in radians."]
pub const cb_field_type_t_CB_RADIAN_FIELD: cb_field_type_t = 11;
#[doc = "< A 32-bit unsigned integer that should be interpreted as a FormID."]
pub const cb_field_type_t_CB_FORMID_FIELD: cb_field_type_t = 12;
#[doc = "< A 32-bit unsigned integer that should be interpreted as an MGEF code."]
pub const cb_field_type_t_CB_MGEFCODE_FIELD: cb_field_type_t = 13;
#[doc = "< A 32-bit unsigned integer that should be interpreted as an actor value."]
pub const cb_field_type_t_CB_ACTORVALUE_FIELD: cb_field_type_t = 14;
#[doc = "< A 32-bit unsigned integer that may be a FormID or not."]
pub const cb_field_type_t_CB_FORMID_OR_UINT32_FIELD: cb_field_type_t = 15;
#[doc = "< A FormID or a 32-bit floating point value."]
pub const cb_field_type_t_CB_FORMID_OR_FLOAT32_FIELD: cb_field_type_t = 16;
#[doc = "< An 8-bit or 32-bit unsigned integer."]
pub const cb_field_type_t_CB_UINT8_OR_UINT32_FIELD: cb_field_type_t = 17;
#[doc = "< A FormID or a C string."]
pub const cb_field_type_t_CB_FORMID_OR_STRING_FIELD: cb_field_type_t = 18;
#[doc = "< A FormID, a 32-bit unsigned integer, or some unknown type."]
pub const cb_field_type_t_CB_UNKNOWN_OR_FORMID_OR_UINT32_FIELD: cb_field_type_t = 19;
#[doc = "< A 32-bit signed integer, or some unknown type."]
pub const cb_field_type_t_CB_UNKNOWN_OR_SINT32_FIELD: cb_field_type_t = 20;
#[doc = "< 32 bits of bit flag values, or some unknown type."]
pub const cb_field_type_t_CB_UNKNOWN_OR_UINT32_FLAG_FIELD: cb_field_type_t = 21;
#[doc = "< An MGEF code or 4 8-bit characters."]
pub const cb_field_type_t_CB_MGEFCODE_OR_CHAR4_FIELD: cb_field_type_t = 22;
#[doc = "< A FormID, an MGEF code, an actor value or a 32-bit unsigned integer."]
pub const cb_field_type_t_CB_FORMID_OR_MGEFCODE_OR_ACTORVALUE_OR_UINT32_FIELD: cb_field_type_t = 23;
#[doc = "< A mod-added MGEF code."]
pub const cb_field_type_t_CB_RESOLVED_MGEFCODE_FIELD: cb_field_type_t = 24;
#[doc = "< A standard MGEF code."]
pub const cb_field_type_t_CB_STATIC_MGEFCODE_FIELD: cb_field_type_t = 25;
#[doc = "< A mod-added actor value."]
pub const cb_field_type_t_CB_RESOLVED_ACTORVALUE_FIELD: cb_field_type_t = 26;
#[doc = "< A standard actor value."]
pub const cb_field_type_t_CB_STATIC_ACTORVALUE_FIELD: cb_field_type_t = 27;
#[doc = "< An 8-bit character."]
pub const cb_field_type_t_CB_CHAR_FIELD: cb_field_type_t = 28;
#[doc = "< 4 8-bit characters."]
pub const cb_field_type_t_CB_CHAR4_FIELD: cb_field_type_t = 29;
#[doc = "< A C string."]
pub const cb_field_type_t_CB_STRING_FIELD: cb_field_type_t = 30;
#[doc = "< A C string that is handled case-insensitively by CBash."]
pub const cb_field_type_t_CB_ISTRING_FIELD: cb_field_type_t = 31;
#[doc = "< A C string, 32-bit floating point value, or 32-bit signed integer."]
pub const cb_field_type_t_CB_STRING_OR_FLOAT32_OR_SINT32_FIELD: cb_field_type_t = 32;
#[doc = "< The field is actually a list of fields."]
pub const cb_field_type_t_CB_LIST_FIELD: cb_field_type_t = 33;
#[doc = "< A parent record of the current record. Eg. each `DIAL` record can have `INFO` record children."]
pub const cb_field_type_t_CB_PARENTRECORD_FIELD: cb_field_type_t = 34;
#[doc = "< A child record associated with the current record (which is the parent). Eg. each `INFO` record is a child of a `DIAL` record."]
pub const cb_field_type_t_CB_SUBRECORD_FIELD: cb_field_type_t = 35;
#[doc = "< Unused."]
pub const cb_field_type_t_CB_SINT8_FLAG_FIELD: cb_field_type_t = 36;
#[doc = "< An 8-bit signed integer that should be interpreted as some enum value."]
pub const cb_field_type_t_CB_SINT8_TYPE_FIELD: cb_field_type_t = 37;
#[doc = "< Unused."]
pub const cb_field_type_t_CB_SINT8_FLAG_TYPE_FIELD: cb_field_type_t = 38;
#[doc = "< Unused."]
pub const cb_field_type_t_CB_SINT8_ARRAY_FIELD: cb_field_type_t = 39;
#[doc = "< 8 bits of bit flag values."]
pub const cb_field_type_t_CB_UINT8_FLAG_FIELD: cb_field_type_t = 40;
#[doc = "< An 8-bit unsigned integer that should be interpreted as some enum value."]
pub const cb_field_type_t_CB_UINT8_TYPE_FIELD: cb_field_type_t = 41;
#[doc = "< An 8-bit unsigned integer that is either a collection of bit flag values or some enum value."]
pub const cb_field_type_t_CB_UINT8_FLAG_TYPE_FIELD: cb_field_type_t = 42;
#[doc = "< An array of 8-bit unsigned integers."]
pub const cb_field_type_t_CB_UINT8_ARRAY_FIELD: cb_field_type_t = 43;
#[doc = "< Unused."]
pub const cb_field_type_t_CB_SINT16_FLAG_FIELD: cb_field_type_t = 44;
#[doc = "< Unused."]
pub const cb_field_type_t_CB_SINT16_TYPE_FIELD: cb_field_type_t = 45;
#[doc = "< Unused."]
pub const cb_field_type_t_CB_SINT16_FLAG_TYPE_FIELD: cb_field_type_t = 46;
#[doc = "< An array of 16-bit unsigned integers."]
pub const cb_field_type_t_CB_SINT16_ARRAY_FIELD: cb_field_type_t = 47;
#[doc = "< 16 bits of bit flag values."]
pub const cb_field_type_t_CB_UINT16_FLAG_FIELD: cb_field_type_t = 48;
#[doc = "< A 16-bit unsigned integer that should be interpreted as some enum value."]
pub const cb_field_type_t_CB_UINT16_TYPE_FIELD: cb_field_type_t = 49;
#[doc = "< Unused."]
pub const cb_field_type_t_CB_UINT16_FLAG_TYPE_FIELD: cb_field_type_t = 50;
#[doc = "< Unused."]
pub const cb_field_type_t_CB_UINT16_ARRAY_FIELD: cb_field_type_t = 51;
#[doc = "< Unused."]
pub const cb_field_type_t_CB_SINT32_FLAG_FIELD: cb_field_type_t = 52;
#[doc = "< A 32-bit signed integer that should be interpreted as some enum value."]
pub const cb_field_type_t_CB_SINT32_TYPE_FIELD: cb_field_type_t = 53;
#[doc = "< Unused."]
pub const cb_field_type_t_CB_SINT32_FLAG_TYPE_FIELD: cb_field_type_t = 54;
#[doc = "< Unused."]
pub const cb_field_type_t_CB_SINT32_ARRAY_FIELD: cb_field_type_t = 55;
#[doc = "< 32 bits of bit flag values."]
pub const cb_field_type_t_CB_UINT32_FLAG_FIELD: cb_field_type_t = 56;
#[doc = "< A 32-bit unsigned integer that should be interpreted as some enum value."]
pub const cb_field_type_t_CB_UINT32_TYPE_FIELD: cb_field_type_t = 57;
#[doc = "< Unused."]
pub const cb_field_type_t_CB_UINT32_FLAG_TYPE_FIELD: cb_field_type_t = 58;
#[doc = "< An array of 32-bit unsigned integers."]
pub const cb_field_type_t_CB_UINT32_ARRAY_FIELD: cb_field_type_t = 59;
#[doc = "< Unused."]
pub const cb_field_type_t_CB_FLOAT32_ARRAY_FIELD: cb_field_type_t = 60;
#[doc = "< Unused."]
pub const cb_field_type_t_CB_RADIAN_ARRAY_FIELD: cb_field_type_t = 61;
#[doc = "< An array of FormIDs."]
pub const cb_field_type_t_CB_FORMID_ARRAY_FIELD: cb_field_type_t = 62;
#[doc = "< An array of FormIDs or 32-bit unsigned integers."]
pub const cb_field_type_t_CB_FORMID_OR_UINT32_ARRAY_FIELD: cb_field_type_t = 63;
#[doc = "< An array of MGEF codes or 32-bit unsigned integers."]
pub const cb_field_type_t_CB_MGEFCODE_OR_UINT32_ARRAY_FIELD: cb_field_type_t = 64;
#[doc = "< Unused."]
pub const cb_field_type_t_CB_STRING_ARRAY_FIELD: cb_field_type_t = 65;
#[doc = "< An array of C strings that are handled case-insensitively by CBash."]
pub const cb_field_type_t_CB_ISTRING_ARRAY_FIELD: cb_field_type_t = 66;
#[doc = "< An array of records that are children associated with the current record (which is their parent). Eg. each `DIAL` record can have `INFO` record children."]
pub const cb_field_type_t_CB_SUBRECORD_ARRAY_FIELD: cb_field_type_t = 67;
#[doc = "< Unused."]
pub const cb_field_type_t_CB_UNDEFINED_FIELD: cb_field_type_t = 68;
#[doc = "@brief Flags that specify the type of a field."]
pub type cb_field_type_t = i32;
extern "C" {
    #[doc = "@brief Get CBash's minor version number."]
    #[doc = "@returns Cbash's major version number."]
    pub fn cb_GetVersionMajor() -> u32;
}
extern "C" {
    #[doc = "@brief Get CBash's minor version number."]
    #[doc = "@returns Cbash's major version number."]
    pub fn cb_GetVersionMinor() -> u32;
}
extern "C" {
    #[doc = "@brief Get CBash's revision (patch) version number."]
    #[doc = "@returns Cbash's revision (patch) version number."]
    pub fn cb_GetVersionRevision() -> u32;
}
extern "C" {
    #[doc = "@brief Register a callback function for logging messages."]
    #[doc = "@param _LoggingCallback A pointer to a callback function. If `NULL`, messages are printed to `stdout`. The callback function must take a message string argument, and returns the number of characters in the message, or `-1` if an error occurred."]
    pub fn cb_RedirectMessages(
        _LoggingCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> i32,
        >,
    );
}
extern "C" {
    #[doc = "@brief Register a callback function for tracing function calls."]
    #[doc = "@details This function is called by many functions if they encounter an error, and is passed the name of the function it is called from. This makes it potentially useful for debugging purposes."]
    #[doc = "@param _RaiseCallback A pointer to a function that takes a string argument and returns nothing. If `NULL`, no function call tracing occurs."]
    pub fn cb_AllowRaising(
        _RaiseCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char),
        >,
    );
}
extern "C" {
    #[doc = "@brief Create a plugin collection."]
    #[doc = "@details Collections are used to manage groups of mod plugins and their data in CBash."]
    #[doc = "@param ModsPath Specifies the path to the folder containing the mod plugins that are to be added to the collection."]
    #[doc = "@param CollectionType Specifies the type of game the collection is for."]
    #[doc = "@returns A pointer to the newly-created cb_collection_t object."]
    pub fn cb_CreateCollection(
        ModsPath: *mut ::std::os::raw::c_char,
        CollectionType: cb_game_type_t,
    ) -> *mut cb_collection_t;
}
extern "C" {
    #[doc = "@brief Delete a plugin collection."]
    #[doc = "@details Deleting a collection frees all associated memory, invalidating associated pointers."]
    #[doc = "@param CollectionID A pointer to the collection to be deleted."]
    #[doc = "@returns `0` on success, `-1` if an error occurred."]
    pub fn cb_DeleteCollection(CollectionID: *mut cb_collection_t) -> i32;
}
extern "C" {
    #[doc = "@brief Loads a collection of plugins."]
    #[doc = "@details Loads the records from the plugins in the given collection into memory, where their data can be accessed."]
    #[doc = "@param CollectionID A pointer to the collection to load."]
    #[doc = "@param _ProgressCallback A pointer to a function to use as a progress callback. If `NULL`, no progress is reported. The function arguments are the load order position of the plugin currently being loaded, the maximum load order position, and the plugin filename. The function returns a boolean that is currently ignored, but may in future be used to signal cancellation of loading by the client."]
    #[doc = "@returns `0` on success, `-1` if an error occurred."]
    pub fn cb_LoadCollection(
        CollectionID: *mut cb_collection_t,
        _ProgressCallback: ::std::option::Option<
            unsafe extern "C" fn(arg1: u32, arg2: u32, arg3: *const ::std::os::raw::c_char) -> bool,
        >,
    ) -> i32;
}
extern "C" {
    #[doc = "@brief Unloads a collection of plugins."]
    #[doc = "@details Unloads any records from the plugins in the given collection that have previously been loaded into memory, without deleting the collection."]
    #[doc = "@param CollectionID A pointer to the collection to unload."]
    #[doc = "@returns `0` on success, `-1` if an error occurred."]
    pub fn cb_UnloadCollection(CollectionID: *mut cb_collection_t) -> i32;
}
extern "C" {
    #[doc = "@brief Get the game type a collection was created for."]
    #[doc = "@param CollectionID The collection to get the game type for."]
    #[doc = "@returns The collection game type."]
    pub fn cb_GetCollectionType(CollectionID: *mut cb_collection_t) -> i32;
}
extern "C" {
    #[doc = "@brief Unload all collections of plugins that have been created by CBash."]
    #[doc = "@details Unloads all loaded collections from memory, without deleting them. Has the same effect as calling cb_UnloadCollection() for each collection that has been created."]
    #[doc = "@returns `0` on success, `-1` if an error occurred."]
    pub fn cb_UnloadAllCollections() -> i32;
}
extern "C" {
    #[doc = "@brief Delete all plugin collections created by CBash."]
    #[doc = "@details Has the same effect as calling cb_UnloadCollection() for each collection that has been created."]
    #[doc = "@returns `0` on success, `-1` if an error occurred."]
    pub fn cb_DeleteAllCollections() -> i32;
}
extern "C" {
    #[doc = "@brief Add a plugin to a collection."]
    #[doc = "@param CollectionID The collection to add the plugin to."]
    #[doc = "@param ModName The filename of the plugin to add."]
    #[doc = "@param ModFlagsField Flags that determine how the plugin is loaded and what can be edited once it has been loaded."]
    #[doc = "@returns A pointer to the plugin object added to the collection."]
    pub fn cb_AddMod(
        CollectionID: *mut cb_collection_t,
        ModName: *mut ::std::os::raw::c_char,
        ModFlagsField: cb_mod_flags_t,
    ) -> *mut cb_mod_t;
}
extern "C" {
    #[doc = "@brief Load a single plugin."]
    #[doc = "@details Loads the records from the given plugin into memory."]
    #[doc = "@param ModID A pointer to the plugin object to load."]
    #[doc = "@returns `0` on success, `-1` if an error occurred."]
    pub fn cb_LoadMod(ModID: *mut cb_mod_t) -> i32;
}
extern "C" {
    #[doc = "@brief Unload a single plugin."]
    #[doc = "@details Unloads the records from the given plugin."]
    #[doc = "@param ModID A pointer to the plugin object to unload."]
    #[doc = "@returns `0` on success, `-1` if an error occurred."]
    pub fn cb_UnloadMod(ModID: *mut cb_mod_t) -> i32;
}
extern "C" {
    #[doc = "@brief Remove unreferenced masters from a plugin."]
    #[doc = "@details This function removes any entries in the given plugin's list of masters that aren't referenced in any of the plugin's records. Note that unreferenced masters are sometimes added to plugins to make explicit an otherwise implicit dependency."]
    #[doc = "@param ModID A pointer to the plugin object for which unreferenced masters should be removed."]
    #[doc = "@returns `0` on success, `-1` if an error occurred."]
    pub fn cb_CleanModMasters(ModID: *mut cb_mod_t) -> i32;
}
extern "C" {
    #[doc = "@brief Save a single plugin's data to a plugin file."]
    #[doc = "@param ModID A pointer to the plugin object to save."]
    #[doc = "@param SaveFlagsField Flags that determine how the plugin is saved."]
    #[doc = "@param DestinationName The output plugin filename."]
    #[doc = "@returns `0` on success, `-1` if an error occurred."]
    pub fn cb_SaveMod(
        ModID: *mut cb_mod_t,
        SaveFlagsField: cb_save_flags_t,
        DestinationName: *mut ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = "@brief Get the number of mods in a collection."]
    #[doc = "@param CollectionID The collection to query."]
    #[doc = "@returns The number of mods in the given collection, or `-1` if an error occurred."]
    pub fn cb_GetAllNumMods(CollectionID: *mut cb_collection_t) -> i32;
}
extern "C" {
    #[doc = "@brief Get an array of plugin object pointers for the plugins in a collection."]
    #[doc = "@param CollectionID The collection to query."]
    #[doc = "@param ModIDs An array of plugin object pointers. The array passed to the function must be preallocated to the correct size, as given by cb_GetAllNumMods(). The array contents are filled by the function to point to the plugin objects within the collection queried."]
    #[doc = "@returns `0` on success, `-1` if an error occurred."]
    pub fn cb_GetAllModIDs(CollectionID: *mut cb_collection_t, ModIDs: *mut *mut cb_mod_t) -> i32;
}
extern "C" {
    #[doc = "@brief Get the number of mods in a collection's load order."]
    #[doc = "@details Returns the number of plugins that were added to the collection with the ::CB_IN_LOAD_ORDER flag."]
    #[doc = "@param CollectionID The collection to query."]
    #[doc = "@returns The number of mods in the given collection's load order, or `-1` if an error occurred."]
    pub fn cb_GetLoadOrderNumMods(CollectionID: *mut cb_collection_t) -> i32;
}
extern "C" {
    #[doc = "@brief Get an array of plugin object pointers for the plugins in a collection's load order."]
    #[doc = "@param CollectionID The collection to query."]
    #[doc = "@param ModIDs An array of plugin object pointers. The array passed to the function must be preallocated to the correct size, as given by cb_GetLoadOrderNumMods(). The array contents are filled by the function to point to the plugin objects within the collection queried."]
    #[doc = "@returns `0` on success, `-1` if an error occurred."]
    pub fn cb_GetLoadOrderModIDs(
        CollectionID: *mut cb_collection_t,
        ModIDs: *mut *mut cb_mod_t,
    ) -> i32;
}
extern "C" {
    #[doc = "@brief Get a plugin's filename from its object pointer."]
    #[doc = "@details The filename will include the `.ghost` extension if the plugin is ghosted."]
    #[doc = "@param ModID The object pointer of the plugin to look up."]
    #[doc = "@returns The plugin's filename, or `NULL` if an error occurred."]
    pub fn cb_GetFileNameByID(ModID: *mut cb_mod_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief Get a plugin's filename from its position in the load order."]
    #[doc = "@details The filename will include the `.ghost` extension if the plugin is ghosted."]
    #[doc = "@param CollectionID The collection to query."]
    #[doc = "@param ModIndex The load order position to look up."]
    #[doc = "@returns The plugin's filename, or `NULL` if an error occurred."]
    pub fn cb_GetFileNameByLoadOrder(
        CollectionID: *mut cb_collection_t,
        ModIndex: u32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief Get a plugin's unghosted filename from its object pointer."]
    #[doc = "@details Returns the same value as cb_GetFileNameByID() for unghosted plugins, and the filename minus the `.ghost` extension for ghosted plugins."]
    #[doc = "@param ModID The object pointer of the plugin to look up."]
    #[doc = "@returns The plugin's unghosted filename, or `NULL` if an error occurred."]
    pub fn cb_GetModNameByID(ModID: *mut cb_mod_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief Get a plugin's unghosted filename from its position in the load order."]
    #[doc = "@details Returns the same value as cb_GetFileNameByLoadOrder() for unghosted plugins, and the filename minus the `.ghost` extension for ghosted plugins."]
    #[doc = "@param CollectionID The collection to query."]
    #[doc = "@param ModIndex The load order position to look up, or `NULL` if an error occurred."]
    #[doc = "@returns The plugin's unghosted filename, or `NULL` if an error occurred."]
    pub fn cb_GetModNameByLoadOrder(
        CollectionID: *mut cb_collection_t,
        ModIndex: u32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief Get a plugin's object using its filename."]
    #[doc = "@param CollectionID The collection to query."]
    #[doc = "@param ModName The plugin filename."]
    #[doc = "@returns A pointer to the plugin object, or `NULL` if the plugin was not found."]
    pub fn cb_GetModIDByName(
        CollectionID: *mut cb_collection_t,
        ModName: *mut ::std::os::raw::c_char,
    ) -> *mut cb_mod_t;
}
extern "C" {
    #[doc = "@brief Get a plugin's object using its position in the load order."]
    #[doc = "@param CollectionID The collection to query."]
    #[doc = "@param ModIndex The load order position to look up."]
    #[doc = "@returns A pointer to the plugin object, or `NULL` if the plugin was not found."]
    pub fn cb_GetModIDByLoadOrder(
        CollectionID: *mut cb_collection_t,
        ModIndex: u32,
    ) -> *mut cb_mod_t;
}
extern "C" {
    #[doc = "@brief Get a plugin's load order position using its filename."]
    #[doc = "@param CollectionID The collection to query."]
    #[doc = "@param ModName The plugin filename to look up."]
    #[doc = "@returns The plugin's load order position, or `-1` if an error occurred."]
    pub fn cb_GetModLoadOrderByName(
        CollectionID: *mut cb_collection_t,
        ModName: *mut ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = "@brief Get a plugin's load order position using its object pointer."]
    #[doc = "@param ModID The plugin's object pointer."]
    #[doc = "@returns The plugin's load order position, or `-1` if an error occurred."]
    pub fn cb_GetModLoadOrderByID(ModID: *mut cb_mod_t) -> i32;
}
extern "C" {
    #[doc = "@brief Get a plugin using a record from it."]
    #[doc = "@param RecordID The record to get the parent plugin of."]
    #[doc = "@returns A plugin pointer, or `NULL` if an error occurred."]
    pub fn cb_GetModIDByRecordID(RecordID: *mut cb_record_t) -> *mut cb_mod_t;
}
extern "C" {
    #[doc = "@brief Get a collection using a record from a plugin in it."]
    #[doc = "@param RecordID The record to get the parent plugin's collection from."]
    #[doc = "@returns A collection pointer, or `NULL` if an error occurred."]
    pub fn cb_GetCollectionIDByRecordID(RecordID: *mut cb_record_t) -> *mut cb_collection_t;
}
extern "C" {
    #[doc = "@brief Get a collection using a plugin in it."]
    #[doc = "@param ModID The plugin to get the parent collection of."]
    #[doc = "@returns A collection pointer, or `NULL` if an error occurred."]
    pub fn cb_GetCollectionIDByModID(ModID: *mut cb_mod_t) -> *mut cb_collection_t;
}
extern "C" {
    #[doc = "@brief Check if a plugin contains any records."]
    #[doc = "@param ModID The plugin to query."]
    #[doc = "@returns `1` if the plugin is empty, `0` otherwise."]
    pub fn cb_IsModEmpty(ModID: *mut cb_mod_t) -> u32;
}
extern "C" {
    #[doc = "@brief Get the number of different record types in a plugin."]
    #[doc = "@details This function will fail unless the plugin was added to the collection with the ::CB_TRACK_NEW_TYPES flag."]
    #[doc = "@param ModID The plugin to query."]
    #[doc = "@returns The number of record types in the plugin, or `-1` if an error occurred."]
    pub fn cb_GetModNumTypes(ModID: *mut cb_mod_t) -> i32;
}
extern "C" {
    #[doc = "@brief Get an array of different record types in a plugin."]
    #[doc = "@details This function will fail unless the plugin was added to the collection with the ::CB_TRACK_NEW_TYPES flag."]
    #[doc = "@param ModID The plugin to query."]
    #[doc = "@param RecordTypes An array of record IDs. Each ID is a four-character sequence in in reverse, eg. `TES4` is stored as `4SET`. The array passed to the function must be preallocated to the correct size, as given by cb_GetModNumTypes(). The array contents are filled by the function."]
    #[doc = "@returns `0` on success, `-1` if an error occurred."]
    pub fn cb_GetModTypes(ModID: *mut cb_mod_t, RecordTypes: *mut u32) -> i32;
}
extern "C" {
    #[doc = "@brief Get the number of empty record groups in a plugin."]
    #[doc = "@param ModID The plugin to query."]
    #[doc = "@returns The number of empty record groups in the plugin, or `-1` if an error occurred."]
    pub fn cb_GetModNumEmptyGRUPs(ModID: *mut cb_mod_t) -> i32;
}
extern "C" {
    #[doc = "@brief Get the number of orphaned records in a plugin."]
    #[doc = "@details Orphaned records are those which reference a parent record that does not exist."]
    #[doc = "@param ModID The plugin to query."]
    #[doc = "@returns The number of orphaned records in the plugin, or `-1` if an error occurred."]
    pub fn cb_GetModNumOrphans(ModID: *mut cb_mod_t) -> i32;
}
extern "C" {
    #[doc = "@brief Get an array of orphaned record FormIDs in a plugin."]
    #[doc = "@details Orphaned records are those which reference a parent record that does not exist."]
    #[doc = "@param ModID The plugin to query."]
    #[doc = "@param FormIDs An outputted array of the FormIDs of the orphaned records in the plugin. The array passed to the function must be preallocated to the correct size, as given by cb_GetModNumOrphans(). The array contents are filled by the function."]
    #[doc = "@returns `0` on success, `-1` if an error occurred."]
    pub fn cb_GetModOrphansFormIDs(ModID: *mut cb_mod_t, FormIDs: *mut cb_formid_t) -> i32;
}
extern "C" {
    #[doc = "@brief Get the long-format FormID for a record."]
    #[doc = "@details Long-format FormIDs convert the mod index stored in the first byte of a FormID into a plugin filename string, for unambiguous referencing independent of load order."]
    #[doc = "@param RecordID The record to query."]
    #[doc = "@param FormID The FormID to get the plugin filename referenced in its mod index byte."]
    #[doc = "@param IsMGEFCode Whether or not the FormID passed is a MGEF code. MGEF (Magic Effect) records are special cases that are referenced using their EditorIDs rather than their FormIDs, so need special handling."]
    #[doc = "@returns The filename of the plugin referenced by the given FormID, or `NULL` if an error occurred."]
    pub fn cb_GetLongIDName(
        RecordID: *mut cb_record_t,
        FormID: u32,
        IsMGEFCode: bool,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief Get a FormID for an object in a plugin."]
    #[doc = "@details  A FormID is composed of a one-byte mod index, and a 3-byte ObjectID. This function combines the mod index of the given plugin with the given ObjectID to create a FormID."]
    #[doc = "@param ModID The plugin to query."]
    #[doc = "@param ObjectID An ObjectID to create a FormID from. The last 3 bytes of the given ObjectID will be used in the FormID produced."]
    #[doc = "@param IsMGEFCode Whether or not the ObjectID passed is for a MGEF code. MGEF (Magic Effect) records are special cases that are referenced using their EditorIDs rather than their FormIDs, so need special handling."]
    #[doc = "@returns The FormID produced, or `NULL` if an error occurred."]
    pub fn cb_MakeShortFormID(ModID: *mut cb_mod_t, ObjectID: u32, IsMGEFCode: bool) -> u32;
}
extern "C" {
    #[doc = "@brief Create a new record."]
    #[doc = "@param ModID The plugin to create the record in."]
    #[doc = "@param RecordType The record type."]
    #[doc = "@param RecordFormID The record FormID."]
    #[doc = "@param RecordEditorID The record EditorID."]
    #[doc = "@param ParentID The parent record for the record to be created. Some record types, usually worldspace-related, have hierarchies of parent and child records. If no parent is desired, `NULL` can be passed."]
    #[doc = "@param CreateFlags Flags that determine how the record is created."]
    #[doc = "@returns A pointer to the created record, or `NULL` if an error was encountered."]
    pub fn cb_CreateRecord(
        ModID: *mut cb_mod_t,
        RecordType: u32,
        RecordFormID: cb_formid_t,
        RecordEditorID: *mut ::std::os::raw::c_char,
        ParentID: *mut cb_record_t,
        CreateFlags: cb_create_flags_t,
    ) -> *mut cb_record_t;
}
extern "C" {
    #[doc = "@brief Copy a record from one plugin into another."]
    #[doc = "@param RecordID The record to be copied."]
    #[doc = "@param DestModID The plugin to copy the record into."]
    #[doc = "@param DestParentID The parent record for the record copy. Some record types, usually worldspace-related, have hierarchies of parent and child records. If no parent is desired, `NULL` can be passed."]
    #[doc = "@param DestRecordFormID The FormID of the record copy."]
    #[doc = "@param DestRecordEditorID The Editor ID of the record copy."]
    #[doc = "@param CreateFlags Flags that determine how the record copy is created."]
    #[doc = "@returns A pointer to the record copy, or `NULL` if an error was encountered."]
    pub fn cb_CopyRecord(
        RecordID: *mut cb_record_t,
        DestModID: *mut cb_mod_t,
        DestParentID: *mut cb_record_t,
        DestRecordFormID: cb_formid_t,
        DestRecordEditorID: *mut ::std::os::raw::c_char,
        CreateFlags: cb_create_flags_t,
    ) -> *mut cb_record_t;
}
extern "C" {
    #[doc = "@brief Unload a record from memory."]
    #[doc = "@details If the record has been changed and the changes are unsaved, it will remain in memory."]
    #[doc = "@param RecordID The record to unload."]
    #[doc = "@returns `1` on success, `0` on failure."]
    pub fn cb_UnloadRecord(RecordID: *mut cb_record_t) -> i32;
}
extern "C" {
    #[doc = "@brief Discards changes made to a record since it was last saved."]
    #[doc = "@details If no changes are present, the function return as if it failed."]
    #[doc = "@param RecordID The record to reset."]
    #[doc = "@returns `1` on success, `0` on failure."]
    pub fn cb_ResetRecord(RecordID: *mut cb_record_t) -> i32;
}
extern "C" {
    #[doc = "@brief Delete a record."]
    #[doc = "@param RecordID The record to delete."]
    #[doc = "@returns `1` on success, `0` on failure."]
    pub fn cb_DeleteRecord(RecordID: *mut cb_record_t) -> i32;
}
extern "C" {
    #[doc = "@brief Get a record from a plugin using its FormID or EditorID."]
    #[doc = "@param ModID The plugin to look in."]
    #[doc = "@param RecordFormID The FormID to look for. If `NULL`, the EditorID value is used."]
    #[doc = "@param RecordEditorID The EditorID to look for, used if the FormID given is `NULL`. If this is also `NULL`, the plugin's TES4 record is returned."]
    #[doc = "@returns The specified record, or `NULL` if an error occurred."]
    pub fn cb_GetRecordID(
        ModID: *mut cb_mod_t,
        RecordFormID: cb_formid_t,
        RecordEditorID: *mut ::std::os::raw::c_char,
    ) -> *mut cb_record_t;
}
extern "C" {
    #[doc = "@brief Get the number of records of a specified type in a plugin."]
    #[doc = "@param ModID The plugin to query."]
    #[doc = "@param RecordType The record type to look for. This should be its 4-byte name in reverse order, eg. to search for `CELL` records, you would pass `'LLEC'`."]
    #[doc = "@returns The number of records of the specified type, or `-1` if an error occurred."]
    pub fn cb_GetNumRecords(ModID: *mut cb_mod_t, RecordType: u32) -> i32;
}
extern "C" {
    #[doc = "@brief Get an array of records of a specified type in a plugin."]
    #[doc = "@param ModID The plugin to query."]
    #[doc = "@param RecordType The record type to look for. This should be its 4-byte name in reverse order, eg. to search for `CELL` records, you would pass a `uint32_t RecordType = 'LLEC';`."]
    #[doc = "@param RecordIDs An array of record pointers, pre-allocated to be of the size given by cb_GetNumRecords(). This function populates the array."]
    #[doc = "@returns The number of records retrieved, or `-1` if an error occurred."]
    pub fn cb_GetRecordIDs(
        ModID: *mut cb_mod_t,
        RecordType: u32,
        RecordIDs: *mut *mut cb_record_t,
    ) -> i32;
}
extern "C" {
    #[doc = "@brief Check if the given record is winning any conflict with other records."]
    #[doc = "@details A record wins a conflict if it is the last-loaded version of that record in the load order."]
    #[doc = "@param RecordID The record to query."]
    #[doc = "@param GetExtendedConflicts If true, checks for conflicts in plugins loaded with the ::CB_EXTENDED_CONFLICTS flag, otherwise they are ignored."]
    #[doc = "@returns `1` if the record is winning, `0` if it is not, and `-1` if an error occurred."]
    pub fn cb_IsRecordWinning(RecordID: *mut cb_record_t, GetExtendedConflicts: bool) -> i32;
}
extern "C" {
    #[doc = "@brief Get the number of conflicting versions of the given record in its parent collection."]
    #[doc = "@param RecordID The record to look for conflicts for."]
    #[doc = "@param GetExtendedConflicts If true, checks for conflicts in plugins loaded with the ::CB_EXTENDED_CONFLICTS flag, otherwise they are ignored."]
    #[doc = "@returns The number of conflicting versions of the record, or `-1` if an error occurred."]
    pub fn cb_GetNumRecordConflicts(RecordID: *mut cb_record_t, GetExtendedConflicts: bool) -> i32;
}
extern "C" {
    #[doc = "@brief Get an array of the different versions of the given record in its parent collection."]
    #[doc = "@param RecordID The record to look for conflicts for."]
    #[doc = "@param RecordIDs An array of record pointers, pre-allocated to be of the size given by cb_GetNumRecordConflicts(). This function populates the array."]
    #[doc = "@param GetExtendedConflicts If true, checks for conflicts in plugins loaded with the ::CB_EXTENDED_CONFLICTS flag, otherwise they are ignored."]
    #[doc = "@returns The number of records retrieved, or `-1` if an error occurred."]
    pub fn cb_GetRecordConflicts(
        RecordID: *mut cb_record_t,
        RecordIDs: *mut *mut cb_record_t,
        GetExtendedConflicts: bool,
    ) -> i32;
}
extern "C" {
    #[doc = "@brief Get an array of the different versions of the given record in its parent collection."]
    #[doc = "@details Unlike cb_GetRecordConflicts(), this function will fail if the given record's parent plugin was loaded with the ::CB_EXTENDED_CONFLICTS flag set, and doesn't include the record passed in the outputted array."]
    #[doc = "@param RecordID The record to look for conflicts for."]
    #[doc = "@param RecordIDs An array of record pointers, pre-allocated to be of the size given by cb_GetNumRecordConflicts(). This function populates the array."]
    #[doc = "@returns The number of records retrieved, or `-1` if an error occurred."]
    pub fn cb_GetRecordHistory(RecordID: *mut cb_record_t, RecordIDs: *mut *mut cb_record_t)
        -> i32;
}
extern "C" {
    #[doc = "@brief Get the number of Identical To Master records in a plugin."]
    #[doc = "@details Identical To Master records are unedited copies of records present in a plugin's masters."]
    #[doc = "@param ModID The plugin to query."]
    #[doc = "@returns The number of Identical To Master records, or `-1` if an error occurred."]
    pub fn cb_GetNumIdenticalToMasterRecords(ModID: *mut cb_mod_t) -> i32;
}
extern "C" {
    #[doc = "@brief Gets an array of the Identical To Master records in a plugin."]
    #[doc = "@details Identical To Master records are unedited copies of records present in a plugin's masters."]
    #[doc = "@param ModID The plugin to query."]
    #[doc = "@param RecordIDs An array of record pointers, pre-allocated to be of the size given by cb_GetNumIdenticalToMasterRecords(). This function populates the array."]
    #[doc = "@returns The number of records the array is populated with, or `-1` if an error occurred."]
    pub fn cb_GetIdenticalToMasterRecords(
        ModID: *mut cb_mod_t,
        RecordIDs: *mut *mut cb_record_t,
    ) -> i32;
}
extern "C" {
    #[doc = "@brief Check if a record's FormID or any of the FormIDs referenced by the record are invalid."]
    #[doc = "@param RecordID The record to check."]
    #[doc = "@returns `1` if the record has or references an invalid FormID, `0` if all the FormIDs it contains are valid, or `-1` if an error occurred."]
    pub fn cb_IsRecordFormIDsInvalid(RecordID: *mut cb_record_t) -> i32;
}
extern "C" {
    #[doc = "@brief Update FormID references in a given plugin or record."]
    #[doc = "@param ModID The plugin to operate on. If `NULL`, RecordID must be non-`NULL`."]
    #[doc = "@param RecordID The record to operate on. If `NULL`, references in all the records in the given plugin will be updated."]
    #[doc = "@param OldFormIDs An input array of the FormIDs to update."]
    #[doc = "@param NewFormIDs An input array of the new FormIDs that correspond to the FormIDs in OldFormIDs."]
    #[doc = "@param Changes An output array of the number of changes made for each FormID that was inputted."]
    #[doc = "@param ArraySize The size of the OldFormIDs, NewFormIDs and Changes arrays."]
    #[doc = "@returns The total number of updated references, or `-1` if an error occurred."]
    pub fn cb_UpdateReferences(
        ModID: *mut cb_mod_t,
        RecordID: *mut cb_record_t,
        OldFormIDs: *mut cb_formid_t,
        NewFormIDs: *mut cb_formid_t,
        Changes: *mut u32,
        ArraySize: u32,
    ) -> i32;
}
extern "C" {
    #[doc = "@brief Check if a record has had its references updated."]
    #[doc = "@param CollectionID The collection to query."]
    #[doc = "@param RecordID The record to query. If `NULL`, all record changes in the collection are discarded."]
    #[doc = "@returns `1` if the record has had its references updated, `0` if not, and `-1` if an error occurred."]
    pub fn cb_GetRecordUpdatedReferences(
        CollectionID: *mut cb_collection_t,
        RecordID: *mut cb_record_t,
    ) -> i32;
}
extern "C" {
    #[doc = "@brief Set the FormID and EditorID of a record."]
    #[doc = "@param RecordID The record to operate on."]
    #[doc = "@param FormID The FormID to set. If `NULL`, the function will exit with error."]
    #[doc = "@param EditorID The EditorID to set. If the EditorID is already in use by another record in the same plugin, the function will exit with error."]
    #[doc = "@returns `1` if the FormID and/or EditorID was changed, or `-1` if nothing was changed or an error occurred."]
    pub fn cb_SetIDFields(
        RecordID: *mut cb_record_t,
        FormID: cb_formid_t,
        EditorID: *mut ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = "@brief Set a record field's value."]
    #[doc = "@details The parameters \\p FieldID, \\p ListIndex, \\p ListFieldID, \\p ListX2Index, \\p ListX2FieldID, \\p ListX3Index and \\p ListX3FieldID take values that vary on a per-record and per-field level. To determine valid values for a particular record field, read the comments in the corresponding functions for the record's `*RecordAPI.cpp` file."]
    #[doc = "@param RecordID The record in which the field is found."]
    #[doc = "@param FieldID"]
    #[doc = "@param ListIndex"]
    #[doc = "@param ListFieldID"]
    #[doc = "@param ListX2Index"]
    #[doc = "@param ListX2FieldID"]
    #[doc = "@param ListX3Index"]
    #[doc = "@param ListX3FieldID"]
    #[doc = "@param FieldValue The value to set. Any memory allocated for the data passed can be freed once the function has completed, as CBash makes a copy of the data."]
    #[doc = "@param ArraySize The length of the data to be set as the field's value."]
    #[doc = "@returns"]
    pub fn cb_SetField(
        RecordID: *mut cb_record_t,
        FieldID: u32,
        ListIndex: u32,
        ListFieldID: u32,
        ListX2Index: u32,
        ListX2FieldID: u32,
        ListX3Index: u32,
        ListX3FieldID: u32,
        FieldValue: *mut ::std::os::raw::c_void,
        ArraySize: u32,
    );
}
extern "C" {
    #[doc = "@brief Delete a field from a record."]
    #[doc = "@details The parameters \\p FieldID, \\p ListIndex, \\p ListFieldID, \\p ListX2Index, \\p ListX2FieldID, \\p ListX3Index and \\p ListX3FieldID take values that vary on a per-record and per-field level. To determine valid values for a particular record field, read the comments in the corresponding functions for the record's `*RecordAPI.cpp` file."]
    #[doc = "@param RecordID The record in which the field is found."]
    #[doc = "@param FieldID"]
    #[doc = "@param ListIndex"]
    #[doc = "@param ListFieldID"]
    #[doc = "@param ListX2Index"]
    #[doc = "@param ListX2FieldID"]
    #[doc = "@param ListX3Index"]
    #[doc = "@param ListX3FieldID"]
    pub fn cb_DeleteField(
        RecordID: *mut cb_record_t,
        FieldID: u32,
        ListIndex: u32,
        ListFieldID: u32,
        ListX2Index: u32,
        ListX2FieldID: u32,
        ListX3Index: u32,
        ListX3FieldID: u32,
    );
}
extern "C" {
    #[doc = "@brief Get the type of a field's value."]
    #[doc = "@details The parameters \\p FieldID, \\p ListIndex, \\p ListFieldID, \\p ListX2Index, \\p ListX2FieldID, \\p ListX3Index, \\p ListX3FieldID and \\p WhichAttribute take values that vary on a per-record and per-field level. To determine valid values for a particular record field, read the comments in the corresponding functions for the record's `*RecordAPI.cpp` file."]
    #[doc = "@param RecordID The record in which the field is found."]
    #[doc = "@param FieldID"]
    #[doc = "@param ListIndex"]
    #[doc = "@param ListFieldID"]
    #[doc = "@param ListX2Index"]
    #[doc = "@param ListX2FieldID"]
    #[doc = "@param ListX3Index"]
    #[doc = "@param ListX3FieldID"]
    #[doc = "@param WhichAttribute For fields that consist of more than one attribute value, this specifies which attribute to get. For single-attribute fields, it is ignored."]
    #[doc = "@returns A ::cb_field_type_t value."]
    pub fn cb_GetFieldAttribute(
        RecordID: *mut cb_record_t,
        FieldID: u32,
        ListIndex: u32,
        ListFieldID: u32,
        ListX2Index: u32,
        ListX2FieldID: u32,
        ListX3Index: u32,
        ListX3FieldID: u32,
        WhichAttribute: u32,
    ) -> u32;
}
extern "C" {
    #[doc = "@brief Get a field's value."]
    #[doc = "@details The parameters \\p FieldID, \\p ListIndex, \\p ListFieldID, \\p ListX2Index, \\p ListX2FieldID, \\p ListX3Index and \\p ListX3FieldID take values that vary on a per-record and per-field level. To determine valid values for a particular record field, read the comments in the corresponding functions for the record's `*RecordAPI.cpp` file."]
    #[doc = "@param RecordID The record in which the field is found."]
    #[doc = "@param FieldID"]
    #[doc = "@param ListIndex"]
    #[doc = "@param ListFieldID"]
    #[doc = "@param ListX2Index"]
    #[doc = "@param ListX2FieldID"]
    #[doc = "@param ListX3Index"]
    #[doc = "@param ListX3FieldID"]
    #[doc = "@param FieldValues"]
    #[doc = "@returns"]
    pub fn cb_GetField(
        RecordID: *mut cb_record_t,
        FieldID: u32,
        ListIndex: u32,
        ListFieldID: u32,
        ListX2Index: u32,
        ListX2FieldID: u32,
        ListX3Index: u32,
        ListX3FieldID: u32,
        FieldValues: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
